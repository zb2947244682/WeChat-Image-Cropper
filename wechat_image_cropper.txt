// components/image-cropper/image-cropper.js
Component({
  properties: {
    // 是否显示组件
    show: {
      type: Boolean,
      value: false
    },
    // 裁切框的最小尺寸
    minSize: {
      type: Number,
      value: 100
    },
    // 输出图片质量 0-1
    quality: {
      type: Number,
      value: 0.8
    }
  },

  data: {
    imageSrc: '',
    imageWidth: 0,
    imageHeight: 0,
    canvasWidth: 0,
    canvasHeight: 0,
    cropBox: {
      x: 50,
      y: 50,
      width: 200,
      height: 200
    },
    isDragging: false,
    isResizing: false,
    dragStart: { x: 0, y: 0 },
    resizeHandle: ''
  },

  methods: {
    // 选择图片
    chooseImage() {
      wx.chooseImage({
        count: 1,
        sizeType: ['original'],
        sourceType: ['album', 'camera'],
        success: (res) => {
          const tempFilePath = res.tempFilePaths[0];
          this.loadImage(tempFilePath);
        }
      });
    },

    // 加载图片
    loadImage(src) {
      wx.getImageInfo({
        src: src,
        success: (res) => {
          // 计算画布尺寸，限制最大尺寸
          const maxWidth = 350;
          const maxHeight = 400;
          let { width, height } = res;
          
          if (width > maxWidth) {
            height = height * maxWidth / width;
            width = maxWidth;
          }
          if (height > maxHeight) {
            width = width * maxHeight / height;
            height = maxHeight;
          }

          this.setData({
            imageSrc: src,
            imageWidth: res.width,
            imageHeight: res.height,
            canvasWidth: width,
            canvasHeight: height,
            cropBox: {
              x: width * 0.1,
              y: height * 0.1,
              width: width * 0.6,
              height: width * 0.6
            }
          });
          
          this.drawCanvas();
        }
      });
    },

    // 绘制画布
    drawCanvas() {
      const query = this.createSelectorQuery();
      query.select('#cropperCanvas').fields({ node: true, size: true }).exec((res) => {
        const canvas = res[0].node;
        const ctx = canvas.getContext('2d');
        
        canvas.width = this.data.canvasWidth;
        canvas.height = this.data.canvasHeight;

        // 清空画布
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 绘制图片
        if (this.data.imageSrc) {
          const img = canvas.createImage();
          img.onload = () => {
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            this.drawCropBox(ctx);
          };
          img.src = this.data.imageSrc;
        }
      });
    },

    // 绘制裁切框
    drawCropBox(ctx) {
      const { cropBox, canvasWidth, canvasHeight } = this.data;
      
      // 绘制遮罩
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, canvasWidth, canvasHeight);
      
      // 清除裁切区域的遮罩
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillRect(cropBox.x, cropBox.y, cropBox.width, cropBox.height);
      
      // 重置混合模式
      ctx.globalCompositeOperation = 'source-over';
      
      // 绘制裁切框边框
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(cropBox.x, cropBox.y, cropBox.width, cropBox.height);
      
      // 绘制角落控制点
      this.drawHandles(ctx);
    },

    // 绘制控制点
    drawHandles(ctx) {
      const { cropBox } = this.data;
      const handleSize = 10;
      
      ctx.fillStyle = '#fff';
      ctx.strokeStyle = '#007aff';
      ctx.lineWidth = 2;
      
      // 四个角的控制点
      const handles = [
        { x: cropBox.x - handleSize/2, y: cropBox.y - handleSize/2 }, // 左上
        { x: cropBox.x + cropBox.width - handleSize/2, y: cropBox.y - handleSize/2 }, // 右上
        { x: cropBox.x - handleSize/2, y: cropBox.y + cropBox.height - handleSize/2 }, // 左下
        { x: cropBox.x + cropBox.width - handleSize/2, y: cropBox.y + cropBox.height - handleSize/2 } // 右下
      ];
      
      handles.forEach(handle => {
        ctx.fillRect(handle.x, handle.y, handleSize, handleSize);
        ctx.strokeRect(handle.x, handle.y, handleSize, handleSize);
      });
    },

    // 触摸开始
    onTouchStart(e) {
      const touch = e.touches[0];
      const { cropBox } = this.data;
      const handleSize = 10;
      
      // 检查是否点击了控制点
      const handles = [
        { type: 'tl', x: cropBox.x, y: cropBox.y },
        { type: 'tr', x: cropBox.x + cropBox.width, y: cropBox.y },
        { type: 'bl', x: cropBox.x, y: cropBox.y + cropBox.height },
        { type: 'br', x: cropBox.x + cropBox.width, y: cropBox.y + cropBox.height }
      ];
      
      for (let handle of handles) {
        if (Math.abs(touch.x - handle.x) <= handleSize && 
            Math.abs(touch.y - handle.y) <= handleSize) {
          this.setData({
            isResizing: true,
            resizeHandle: handle.type,
            dragStart: { x: touch.x, y: touch.y }
          });
          return;
        }
      }
      
      // 检查是否点击了裁切框内部
      if (touch.x >= cropBox.x && touch.x <= cropBox.x + cropBox.width &&
          touch.y >= cropBox.y && touch.y <= cropBox.y + cropBox.height) {
        this.setData({
          isDragging: true,
          dragStart: { x: touch.x - cropBox.x, y: touch.y - cropBox.y }
        });
      }
    },

    // 触摸移动
    onTouchMove(e) {
      const touch = e.touches[0];
      const { isDragging, isResizing, dragStart, cropBox, canvasWidth, canvasHeight, minSize } = this.data;
      
      if (isDragging) {
        // 移动裁切框
        let newX = touch.x - dragStart.x;
        let newY = touch.y - dragStart.y;
        
        // 边界检查
        newX = Math.max(0, Math.min(newX, canvasWidth - cropBox.width));
        newY = Math.max(0, Math.min(newY, canvasHeight - cropBox.height));
        
        this.setData({
          'cropBox.x': newX,
          'cropBox.y': newY
        });
        
        this.drawCanvas();
      } else if (isResizing) {
        // 调整裁切框大小
        const deltaX = touch.x - dragStart.x;
        const deltaY = touch.y - dragStart.y;
        let newCropBox = { ...cropBox };
        
        switch (this.data.resizeHandle) {
          case 'tl':
            newCropBox.width = Math.max(minSize, cropBox.width - deltaX);
            newCropBox.height = Math.max(minSize, cropBox.height - deltaY);
            newCropBox.x = cropBox.x + cropBox.width - newCropBox.width;
            newCropBox.y = cropBox.y + cropBox.height - newCropBox.height;
            break;
          case 'tr':
            newCropBox.width = Math.max(minSize, cropBox.width + deltaX);
            newCropBox.height = Math.max(minSize, cropBox.height - deltaY);
            newCropBox.y = cropBox.y + cropBox.height - newCropBox.height;
            break;
          case 'bl':
            newCropBox.width = Math.max(minSize, cropBox.width - deltaX);
            newCropBox.height = Math.max(minSize, cropBox.height + deltaY);
            newCropBox.x = cropBox.x + cropBox.width - newCropBox.width;
            break;
          case 'br':
            newCropBox.width = Math.max(minSize, cropBox.width + deltaX);
            newCropBox.height = Math.max(minSize, cropBox.height + deltaY);
            break;
        }
        
        // 边界检查
        if (newCropBox.x >= 0 && newCropBox.y >= 0 && 
            newCropBox.x + newCropBox.width <= canvasWidth &&
            newCropBox.y + newCropBox.height <= canvasHeight) {
          this.setData({ cropBox: newCropBox });
          this.drawCanvas();
        }
      }
    },

    // 触摸结束
    onTouchEnd() {
      this.setData({
        isDragging: false,
        isResizing: false,
        resizeHandle: ''
      });
    },

    // 确认裁切
    confirmCrop() {
      const { imageSrc, cropBox, canvasWidth, canvasHeight, imageWidth, imageHeight, quality } = this.data;
      
      // 计算实际裁切区域
      const scaleX = imageWidth / canvasWidth;
      const scaleY = imageHeight / canvasHeight;
      const realCropBox = {
        x: cropBox.x * scaleX,
        y: cropBox.y * scaleY,
        width: cropBox.width * scaleX,
        height: cropBox.height * scaleY
      };
      
      // 创建临时canvas进行裁切
      const query = this.createSelectorQuery();
      query.select('#tempCanvas').fields({ node: true, size: true }).exec((res) => {
        const canvas = res[0].node;
        const ctx = canvas.getContext('2d');
        
        canvas.width = realCropBox.width;
        canvas.height = realCropBox.height;
        
        const img = canvas.createImage();
        img.onload = () => {
          ctx.drawImage(
            img,
            realCropBox.x, realCropBox.y, realCropBox.width, realCropBox.height,
            0, 0, realCropBox.width, realCropBox.height
          );
          
          // 转换为临时文件
          wx.canvasToTempFilePath({
            canvas: canvas,
            quality: quality,
            success: (res) => {
              this.triggerEvent('cropped', {
                tempFilePath: res.tempFilePath,
                width: realCropBox.width,
                height: realCropBox.height
              });
              this.close();
            }
          });
        };
        img.src = imageSrc;
      });
    },

    // 取消
    cancel() {
      this.triggerEvent('cancel');
      this.close();
    },

    // 关闭组件
    close() {
      this.setData({
        show: false,
        imageSrc: '',
        isDragging: false,
        isResizing: false
      });
    }
  }
});



// components/image-cropper/image-cropper.wxml
<!--
<view class="image-cropper" wx:if="{{show}}">
  <view class="cropper-container">
    <view class="cropper-header">
      <text class="title">裁切图片</text>
    </view>
    
    <view class="cropper-content">
      <view class="canvas-container" wx:if="{{imageSrc}}">
        <canvas 
          id="cropperCanvas" 
          type="2d"
          class="cropper-canvas"
          style="width: {{canvasWidth}}px; height: {{canvasHeight}}px;"
          bindtouchstart="onTouchStart"
          bindtouchmove="onTouchMove"
          bindtouchend="onTouchEnd"
        ></canvas>
      </view>
      
      <view class="select-image" wx:else>
        <button class="select-btn" bindtap="chooseImage">选择图片</button>
      </view>
    </view>
    
    <view class="cropper-footer" wx:if="{{imageSrc}}">
      <button class="btn cancel-btn" bindtap="cancel">取消</button>
      <button class="btn confirm-btn" bindtap="confirmCrop">确认</button>
    </view>
  </view>
  
  <canvas id="tempCanvas" type="2d" class="temp-canvas"></canvas>
</view>
-->



// components/image-cropper/image-cropper.wxss
/* 
.image-cropper {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.8);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.cropper-container {
  background: #fff;
  border-radius: 10px;
  overflow: hidden;
  max-width: 90vw;
  max-height: 80vh;
}

.cropper-header {
  padding: 20px;
  border-bottom: 1px solid #f0f0f0;
  text-align: center;
}

.title {
  font-size: 18px;
  font-weight: bold;
}

.cropper-content {
  padding: 20px;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
}

.canvas-container {
  position: relative;
}

.cropper-canvas {
  border: 1px solid #ddd;
}

.select-image {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

.select-btn {
  padding: 12px 24px;
  background: #007aff;
  color: #fff;
  border: none;
  border-radius: 6px;
  font-size: 16px;
}

.cropper-footer {
  padding: 20px;
  border-top: 1px solid #f0f0f0;
  display: flex;
  justify-content: space-between;
}

.btn {
  flex: 1;
  padding: 12px;
  border: none;
  border-radius: 6px;
  font-size: 16px;
  margin: 0 10px;
}

.cancel-btn {
  background: #f0f0f0;
  color: #333;
}

.confirm-btn {
  background: #007aff;
  color: #fff;
}

.temp-canvas {
  position: absolute;
  left: -9999px;
  top: -9999px;
  width: 1px;
  height: 1px;
}
*/



// components/image-cropper/image-cropper.json
/*
{
  "component": true,
  "usingComponents": {}
}
*/

// 使用示例 - 在页面中使用组件
// pages/index/index.js
/*
Page({
  data: {
    showCropper: false
  },

  // 显示裁切组件
  showImageCropper() {
    this.setData({
      showCropper: true
    });
  },

  // 裁切完成回调
  onImageCropped(e) {
    console.log('裁切完成:', e.detail);
    const { tempFilePath, width, height } = e.detail;
    
    // 这里可以处理裁切后的图片
    // 例如上传到服务器或显示预览
    wx.showToast({
      title: '裁切成功',
      icon: 'success'
    });
  },

  // 取消裁切回调
  onCropCancel() {
    console.log('取消裁切');
  }
});
*/

// pages/index/index.json
/*
{
  "usingComponents": {
    "image-cropper": "/components/image-cropper/image-cropper"
  }
}
*/

// pages/index/index.wxml
/*
<view class="container">
  <button bindtap="showImageCropper">打开图片裁切</button>
  
  <image-cropper 
    show="{{showCropper}}"
    min-size="{{100}}"
    quality="{{0.8}}"
    bind:cropped="onImageCropped"
    bind:cancel="onCropCancel"
  />
</view>
*/